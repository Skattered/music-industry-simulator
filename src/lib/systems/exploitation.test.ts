/**
 * Tests for Exploitation Abilities System
 */

import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
	activateAbility,
	processActiveBoosts,
	getAvailableAbilities,
	calculateAbilityCost,
	isAbilityActive,
	getAbilityRemainingDuration,
	getActiveBoostMultipliers
} from './exploitation';
import type { GameState } from '../game/types';
import {
	INITIAL_MONEY,
	INITIAL_FANS,
	INITIAL_GPU,
	INITIAL_TECH_TIER,
	INITIAL_TECH_SUB_TIER,
	INITIAL_PHASE,
	INITIAL_INDUSTRY_CONTROL,
	INITIAL_PRESTIGE_COUNT,
	INITIAL_EXPERIENCE_MULTIPLIER,
	BASE_SONG_GENERATION_TIME,
	INITIAL_UNLOCKED_SYSTEMS
} from '../game/config';

/**
 * Create a test GameState with default values
 */
function createTestGameState(overrides?: Partial<GameState>): GameState {
	return {
		money: INITIAL_MONEY,
		songs: [],
		fans: INITIAL_FANS,
		gpu: INITIAL_GPU,
		phase: INITIAL_PHASE,
		industryControl: INITIAL_INDUSTRY_CONTROL,
		currentArtist: {
			name: 'Test Artist',
			songs: 0,
			fans: 0,
			peakFans: 0,
			createdAt: Date.now()
		},
		legacyArtists: [],
		songQueue: [],
		songGenerationSpeed: BASE_SONG_GENERATION_TIME,
		currentTrendingGenre: null,
		trendDiscoveredAt: null,
		techTier: INITIAL_TECH_TIER,
		techSubTier: INITIAL_TECH_SUB_TIER,
		upgrades: {},
		activeBoosts: [],
		boostUsageCounts: {},
		physicalAlbums: [],
		tours: [],
		ownedPlatforms: [],
		prestigeCount: INITIAL_PRESTIGE_COUNT,
		experienceMultiplier: INITIAL_EXPERIENCE_MULTIPLIER,
		unlockedSystems: { ...INITIAL_UNLOCKED_SYSTEMS },
		lastUpdate: Date.now(),
		createdAt: Date.now(),
		version: '1.0.0',
		...overrides
	};
}

describe('Exploitation System', () => {
	describe('getAvailableAbilities', () => {
		it('should return streaming phase abilities by default', () => {
			const state = createTestGameState();
			const available = getAvailableAbilities(state);

			// Should have bot_streams, playlist_placement, social_media
			expect(available.length).toBeGreaterThanOrEqual(3);
			expect(available.find((a) => a.id === 'bot_streams')).toBeDefined();
			expect(available.find((a) => a.id === 'playlist_placement')).toBeDefined();
			expect(available.find((a) => a.id === 'social_media')).toBeDefined();
		});

		it('should include physical abilities when physicalAlbums unlocked', () => {
			const state = createTestGameState({
				unlockedSystems: {
					...INITIAL_UNLOCKED_SYSTEMS,
					physicalAlbums: true
				}
			});

			const available = getAvailableAbilities(state);

			expect(available.find((a) => a.id === 'limited_variants')).toBeDefined();
			expect(available.find((a) => a.id === 'shut_down_competitors')).toBeDefined();
			expect(available.find((a) => a.id === 'exclusive_deals')).toBeDefined();
		});

		it('should include tour abilities when tours unlocked', () => {
			const state = createTestGameState({
				unlockedSystems: {
					...INITIAL_UNLOCKED_SYSTEMS,
					tours: true
				}
			});

			const available = getAvailableAbilities(state);

			expect(available.find((a) => a.id === 'scalp_records')).toBeDefined();
			expect(available.find((a) => a.id === 'limit_tickets')).toBeDefined();
			expect(available.find((a) => a.id === 'scalp_tickets')).toBeDefined();
			expect(available.find((a) => a.id === 'fomo_marketing')).toBeDefined();
		});

		it('should include platform abilities when platformOwnership unlocked', () => {
			const state = createTestGameState({
				unlockedSystems: {
					...INITIAL_UNLOCKED_SYSTEMS,
					platformOwnership: true
				}
			});

			const available = getAvailableAbilities(state);

			expect(available.find((a) => a.id === 'dynamic_pricing')).toBeDefined();
		});

		it('should return all abilities when all systems unlocked', () => {
			const state = createTestGameState({
				unlockedSystems: {
					trendResearch: true,
					physicalAlbums: true,
					tours: true,
					platformOwnership: true,
					monopoly: true,
					prestige: true,
					gpu: true
				}
			});

			const available = getAvailableAbilities(state);

			// Should have all 11 boost types
			expect(available.length).toBe(11);
		});
	});

	describe('calculateAbilityCost', () => {
		it('should return base cost for first use', () => {
			const state = createTestGameState();

			// Bot streams has base cost of 50,000
			const cost = calculateAbilityCost(state, 'bot_streams');
			expect(cost).toBe(50_000);
		});

		it('should scale cost based on usage count', () => {
			const state = createTestGameState({
				boostUsageCounts: {
					bot_streams: 1
				}
			});

			// Base cost 50,000, scaling 1.5, usage 1
			// Cost = 50,000 * (1.5 ^ 1) = 75,000
			const cost = calculateAbilityCost(state, 'bot_streams');
			expect(cost).toBe(75_000);
		});

		it('should compound scaling for multiple uses', () => {
			const state = createTestGameState({
				boostUsageCounts: {
					bot_streams: 3
				}
			});

			// Base cost 50,000, scaling 1.5, usage 3
			// Cost = 50,000 * (1.5 ^ 3) = 50,000 * 3.375 = 168,750
			const cost = calculateAbilityCost(state, 'bot_streams');
			expect(cost).toBe(168_750);
		});

		it('should return 0 for unknown ability', () => {
			const state = createTestGameState();
			const cost = calculateAbilityCost(state, 'unknown_ability');
			expect(cost).toBe(0);
		});

		it('should handle different abilities independently', () => {
			const state = createTestGameState({
				boostUsageCounts: {
					bot_streams: 2,
					playlist_placement: 1
				}
			});

			const botCost = calculateAbilityCost(state, 'bot_streams');
			const playlistCost = calculateAbilityCost(state, 'playlist_placement');

			// Bot streams: 50,000 * (1.5 ^ 2) = 112,500
			expect(botCost).toBe(112_500);

			// Playlist placement: 250,000 * (1.5 ^ 1) = 375,000
			expect(playlistCost).toBe(375_000);
		});
	});

	describe('activateAbility', () => {
		it('should activate ability and deduct cost', () => {
			const state = createTestGameState({
				money: 100_000
			});

			const result = activateAbility(state, 'bot_streams');

			expect(result).toBe(true);
			expect(state.money).toBe(50_000); // 100,000 - 50,000
			expect(state.activeBoosts.length).toBe(1);
		});

		it('should create active boost with correct properties', () => {
			const state = createTestGameState({
				money: 200_000
			});

			activateAbility(state, 'bot_streams');

			const boost = state.activeBoosts[0];
			expect(boost.type).toBe('bot_streams');
			expect(boost.name).toBe('Bot Streams');
			expect(boost.duration).toBe(30000); // 30 seconds
			expect(boost.incomeMultiplier).toBe(3.0);
			expect(boost.fanMultiplier).toBe(1.5);
			expect(boost.activatedAt).toBeCloseTo(Date.now(), -2); // Within 100ms
		});

		it('should increment usage count', () => {
			const state = createTestGameState({
				money: 200_000
			});

			activateAbility(state, 'bot_streams');

			expect(state.boostUsageCounts['bot_streams']).toBe(1);
		});

		it('should increment existing usage count', () => {
			const state = createTestGameState({
				money: 500_000,
				boostUsageCounts: {
					bot_streams: 2
				}
			});

			activateAbility(state, 'bot_streams');

			expect(state.boostUsageCounts['bot_streams']).toBe(3);
		});

		it('should fail if insufficient funds', () => {
			const state = createTestGameState({
				money: 25_000 // Not enough for bot_streams (50,000)
			});

			const result = activateAbility(state, 'bot_streams');

			expect(result).toBe(false);
			expect(state.money).toBe(25_000); // Unchanged
			expect(state.activeBoosts.length).toBe(0);
		});

		it('should fail for unknown ability', () => {
			const state = createTestGameState({
				money: 1_000_000
			});

			const result = activateAbility(state, 'unknown_ability');

			expect(result).toBe(false);
			expect(state.money).toBe(1_000_000); // Unchanged
		});

		it('should fail for locked ability', () => {
			const state = createTestGameState({
				money: 10_000_000,
				unlockedSystems: {
					...INITIAL_UNLOCKED_SYSTEMS,
					tours: false // Tours not unlocked
				}
			});

			const result = activateAbility(state, 'scalp_tickets');

			expect(result).toBe(false);
			expect(state.money).toBe(10_000_000); // Unchanged
		});

		it('should allow multiple abilities to be active simultaneously', () => {
			const state = createTestGameState({
				money: 2_000_000
			});

			activateAbility(state, 'bot_streams');
			activateAbility(state, 'playlist_placement');
			activateAbility(state, 'social_media');

			expect(state.activeBoosts.length).toBe(3);
		});

		it('should allow same ability to be activated multiple times', () => {
			const state = createTestGameState({
				money: 1_000_000
			});

			activateAbility(state, 'bot_streams'); // 50,000
			activateAbility(state, 'bot_streams'); // 75,000 (scaled)

			expect(state.activeBoosts.length).toBe(2);
			expect(state.boostUsageCounts['bot_streams']).toBe(2);
			// Should have spent 50,000 + 75,000 = 125,000
			expect(state.money).toBe(875_000);
		});
	});

	describe('processActiveBoosts', () => {
		it('should keep active boosts within duration', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000, // 10 seconds ago
						duration: 30000, // 30 second duration
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(1);
		});

		it('should remove expired boosts', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 40000, // 40 seconds ago
						duration: 30000, // 30 second duration (expired 10 seconds ago)
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(0);
		});

		it('should handle multiple boosts with different expiration times', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000, // Still active
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test-2',
						type: 'playlist_placement',
						name: 'Playlist Payola',
						activatedAt: now - 70000, // Expired
						duration: 60000,
						incomeMultiplier: 2.5,
						fanMultiplier: 3.0
					},
					{
						id: 'test-3',
						type: 'social_media_campaign',
						name: 'Viral Marketing',
						activatedAt: now - 20000, // Still active
						duration: 45000,
						incomeMultiplier: 2.0,
						fanMultiplier: 5.0
					}
				]
			});

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(2);
			expect(state.activeBoosts.find((b) => b.type === 'bot_streams')).toBeDefined();
			expect(state.activeBoosts.find((b) => b.type === 'social_media_campaign')).toBeDefined();
			expect(state.activeBoosts.find((b) => b.type === 'playlist_placement')).toBeUndefined();
		});

		it('should handle empty active boosts', () => {
			const state = createTestGameState({
				activeBoosts: []
			});

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(0);
		});
	});

	describe('isAbilityActive', () => {
		it('should return true for active ability', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			expect(isAbilityActive(state, 'bot_streams')).toBe(true);
		});

		it('should return false for expired ability', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 40000, // Expired
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			expect(isAbilityActive(state, 'bot_streams')).toBe(false);
		});

		it('should return false for inactive ability', () => {
			const state = createTestGameState({
				activeBoosts: []
			});

			expect(isAbilityActive(state, 'bot_streams')).toBe(false);
		});

		it('should return false for unknown ability', () => {
			const state = createTestGameState({
				activeBoosts: []
			});

			expect(isAbilityActive(state, 'unknown_ability')).toBe(false);
		});
	});

	describe('getAbilityRemainingDuration', () => {
		it('should return remaining duration for active ability', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000, // 10 seconds ago
						duration: 30000, // 30 seconds total
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			const remaining = getAbilityRemainingDuration(state, 'bot_streams');
			expect(remaining).toBeCloseTo(20000, -2); // 20 seconds remaining
		});

		it('should return 0 for expired ability', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 40000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			const remaining = getAbilityRemainingDuration(state, 'bot_streams');
			expect(remaining).toBe(0);
		});

		it('should return 0 for inactive ability', () => {
			const state = createTestGameState({
				activeBoosts: []
			});

			const remaining = getAbilityRemainingDuration(state, 'bot_streams');
			expect(remaining).toBe(0);
		});

		it('should return max remaining for multiple instances', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 20000, // 10 seconds remaining
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test-2',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 5000, // 25 seconds remaining
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			const remaining = getAbilityRemainingDuration(state, 'bot_streams');
			expect(remaining).toBeCloseTo(25000, -2);
		});
	});

	describe('getActiveBoostMultipliers', () => {
		it('should return 1.0 for no active boosts', () => {
			const state = createTestGameState({
				activeBoosts: []
			});

			const multipliers = getActiveBoostMultipliers(state);

			expect(multipliers.incomeMultiplier).toBe(1.0);
			expect(multipliers.fanMultiplier).toBe(1.0);
		});

		it('should return correct multipliers for single boost', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			const multipliers = getActiveBoostMultipliers(state);

			expect(multipliers.incomeMultiplier).toBe(3.0);
			expect(multipliers.fanMultiplier).toBe(1.5);
		});

		it('should multiply stacked boosts', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test-2',
						type: 'playlist_placement',
						name: 'Playlist Payola',
						activatedAt: now - 5000,
						duration: 60000,
						incomeMultiplier: 2.5,
						fanMultiplier: 3.0
					}
				]
			});

			const multipliers = getActiveBoostMultipliers(state);

			expect(multipliers.incomeMultiplier).toBe(7.5); // 3.0 * 2.5
			expect(multipliers.fanMultiplier).toBe(4.5); // 1.5 * 3.0
		});

		it('should ignore expired boosts', () => {
			const now = Date.now();
			const state = createTestGameState({
				activeBoosts: [
					{
						id: 'test-1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test-2',
						type: 'playlist_placement',
						name: 'Playlist Payola',
						activatedAt: now - 70000, // Expired
						duration: 60000,
						incomeMultiplier: 2.5,
						fanMultiplier: 3.0
					}
				]
			});

			const multipliers = getActiveBoostMultipliers(state);

			// Only first boost should count
			expect(multipliers.incomeMultiplier).toBe(3.0);
			expect(multipliers.fanMultiplier).toBe(1.5);
		});
	});
});
