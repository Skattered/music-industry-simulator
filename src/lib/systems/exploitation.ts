/**
 * Exploitation Abilities System
 *
 * Handles activation and management of temporary exploitation abilities.
 * These are morally questionable but profitable tactics that provide temporary boosts.
 *
 * Design principles:
 * - No cooldowns, just escalating costs
 * - Multiple abilities can be active simultaneously
 * - Costs scale with each use (1.5x multiplier by default)
 * - Duration-based temporary effects
 * - Creates active "spend money to make more money" gameplay
 */

import type { GameState, ActiveBoost, BoostDefinition } from '../game/types';
import { BOOSTS } from '../game/config';

// Create a Map for O(1) boost definition lookups
const BOOST_MAP = new Map<string, BoostDefinition>(BOOSTS.map((b) => [b.id, b]));

/**
 * Get all available abilities that can be activated
 * Filters based on game phase and unlocked systems
 *
 * @param state - Current game state
 * @returns Array of available ability definitions
 */
export function getAvailableAbilities(state: GameState): BoostDefinition[] {
	const available: BoostDefinition[] = [];

	for (const boost of BOOSTS) {
		// Phase-based unlock logic
		// Phase 1 (Streaming): bot_streams, playlist_placement, social_media
		// Phase 2 (Physical): limited_variants, shut_down_competitors, exclusive_deals
		// Phase 3 (Tours): scalp_records, limit_tickets, scalp_tickets, fomo_marketing
		// Phase 4+ (Platform): dynamic_pricing

		let unlocked = false;

		// Streaming phase abilities (always available)
		if (boost.id === 'bot_streams' || boost.id === 'playlist_placement' || boost.id === 'social_media') {
			unlocked = true;
		}

		// Physical phase abilities (unlock with physical albums)
		if (
			state.unlockedSystems.physicalAlbums &&
			(boost.id === 'limited_variants' ||
				boost.id === 'shut_down_competitors' ||
				boost.id === 'exclusive_deals')
		) {
			unlocked = true;
		}

		// Tour phase abilities (unlock with tours)
		if (
			state.unlockedSystems.tours &&
			(boost.id === 'scalp_records' ||
				boost.id === 'limit_tickets' ||
				boost.id === 'scalp_tickets' ||
				boost.id === 'fomo_marketing')
		) {
			unlocked = true;
		}

		// Platform ownership abilities (unlock with platform ownership)
		if (state.unlockedSystems.platformOwnership && boost.id === 'dynamic_pricing') {
			unlocked = true;
		}

		if (unlocked) {
			available.push(boost);
		}
	}

	return available;
}

/**
 * Calculate the current cost to activate an ability
 * Cost scales based on number of times it's been used
 *
 * Formula: baseCost * (costScaling ^ usageCount)
 *
 * @param state - Current game state
 * @param abilityId - The ability ID to calculate cost for
 * @returns The current activation cost, or 0 if ability not found
 */
export function calculateAbilityCost(state: GameState, abilityId: string): number {
	const definition = BOOST_MAP.get(abilityId);
	if (!definition) {
		return 0;
	}

	// Get usage count (defaults to 0 if never used)
	const usageCount = state.boostUsageCounts[abilityId] || 0;

	// Calculate scaled cost: baseCost * (costScaling ^ usageCount)
	const cost = definition.baseCost * Math.pow(definition.costScaling, usageCount);

	return cost;
}

/**
 * Activate an exploitation ability
 * Deducts cost, creates an active boost, and increments usage count
 *
 * @param state - Current game state (will be mutated)
 * @param abilityId - The ability ID to activate
 * @returns true if activated successfully, false if insufficient funds or ability not found
 */
export function activateAbility(state: GameState, abilityId: string): boolean {
	const definition = BOOST_MAP.get(abilityId);
	if (!definition) {
		console.warn(`activateAbility: Unknown ability ID "${abilityId}"`);
		return false;
	}

	// Check if ability is available (unlocked)
	const available = getAvailableAbilities(state);
	if (!available.find((a) => a.id === abilityId)) {
		console.warn(`activateAbility: Ability "${abilityId}" is not unlocked yet`);
		return false;
	}

	// Calculate current cost
	const cost = calculateAbilityCost(state, abilityId);

	// Check if player can afford
	if (state.money < cost) {
		return false;
	}

	// Deduct cost
	state.money -= cost;

	// Create active boost
	const activeBoost: ActiveBoost = {
		id: crypto.randomUUID(),
		type: definition.type,
		name: definition.name,
		activatedAt: Date.now(),
		duration: definition.duration,
		incomeMultiplier: definition.incomeMultiplier,
		fanMultiplier: definition.fanMultiplier
	};

	// Add to active boosts
	state.activeBoosts.push(activeBoost);

	// Increment usage count
	if (!state.boostUsageCounts[abilityId]) {
		state.boostUsageCounts[abilityId] = 0;
	}
	state.boostUsageCounts[abilityId]++;

	return true;
}

/**
 * Process active boosts and remove expired ones
 * Called each game tick to clean up expired boosts
 *
 * @param state - Current game state (will be mutated)
 * @param deltaTime - Time elapsed since last update in milliseconds (unused but kept for consistency)
 */
export function processActiveBoosts(state: GameState, deltaTime: number): void {
	const currentTime = Date.now();

	// Filter out expired boosts
	state.activeBoosts = state.activeBoosts.filter((boost: ActiveBoost) => {
		const elapsed = currentTime - boost.activatedAt;
		return elapsed < boost.duration;
	});
}

/**
 * Check if a specific ability is currently active
 *
 * @param state - Current game state
 * @param abilityId - The ability ID to check (matches boost type)
 * @returns true if at least one instance of this ability is active
 */
export function isAbilityActive(state: GameState, abilityId: string): boolean {
	const definition = BOOST_MAP.get(abilityId);
	if (!definition) {
		return false;
	}

	const currentTime = Date.now();

	for (const boost of state.activeBoosts) {
		if (boost.type === definition.type) {
			const elapsed = currentTime - boost.activatedAt;
			if (elapsed < boost.duration) {
				return true;
			}
		}
	}

	return false;
}

/**
 * Get the remaining duration for an active ability
 *
 * @param state - Current game state
 * @param abilityId - The ability ID to check
 * @returns Remaining duration in milliseconds, or 0 if not active
 */
export function getAbilityRemainingDuration(state: GameState, abilityId: string): number {
	const definition = BOOST_MAP.get(abilityId);
	if (!definition) {
		return 0;
	}

	const currentTime = Date.now();
	let maxRemaining = 0;

	for (const boost of state.activeBoosts) {
		if (boost.type === definition.type) {
			const elapsed = currentTime - boost.activatedAt;
			const remaining = boost.duration - elapsed;

			if (remaining > maxRemaining) {
				maxRemaining = remaining;
			}
		}
	}

	return maxRemaining;
}

/**
 * Get the total combined multipliers from all active abilities
 *
 * @param state - Current game state
 * @returns Object containing combined income and fan multipliers
 */
export function getActiveBoostMultipliers(
	state: GameState
): { incomeMultiplier: number; fanMultiplier: number } {
	let incomeMultiplier = 1.0;
	let fanMultiplier = 1.0;

	const currentTime = Date.now();

	for (const boost of state.activeBoosts) {
		const elapsed = currentTime - boost.activatedAt;
		if (elapsed < boost.duration) {
			incomeMultiplier *= boost.incomeMultiplier;
			fanMultiplier *= boost.fanMultiplier;
		}
	}

	return {
		incomeMultiplier,
		fanMultiplier
	};
}
