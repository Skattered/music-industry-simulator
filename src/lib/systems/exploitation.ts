/**
 * Exploitation Abilities System
 *
 * Handles activated abilities that provide temporary boosts to income and fans.
 * These are morally questionable but profitable tactics that scale in cost with each use.
 *
 * Key Features:
 * - Temporary boosts with fixed durations
 * - Costs scale up with each use (no cooldowns)
 * - Multiple abilities can be active simultaneously
 * - Different abilities unlock at different game phases
 *
 * Design Philosophy:
 * - Creates active "spend money to make more money" gameplay
 * - Balances spending vs saving for upgrades
 * - Escalating costs prevent spam while allowing strategic use
 */

import type { GameState, ActiveBoost, BoostType, BoostDefinition } from '../game/types';
import { BOOSTS } from '../game/config';

/**
 * Activate an exploitation ability
 * Deducts cost from money and adds the boost to active boosts
 *
 * @param state - The current game state (will be mutated)
 * @param abilityId - The unique ID of the ability to activate
 * @returns True if activation succeeded, false if failed (insufficient funds, ability not found, etc.)
 */
export function activateAbility(state: GameState, abilityId: string): boolean {
	// Find the ability definition
	const abilityDef = getAbilityById(abilityId);
	if (!abilityDef) {
		return false;
	}

	// Check if ability is available (unlocked for current phase)
	const availableAbilities = getAvailableAbilities(state);
	if (!availableAbilities.find((a) => a.id === abilityId)) {
		return false;
	}

	// Calculate current cost based on usage
	const cost = calculateAbilityCost(state, abilityId);

	// Check if player can afford it
	if (state.money < cost) {
		return false;
	}

	// Deduct cost
	state.money -= cost;

	// Create the active boost
	const now = Date.now();
	// Use crypto.randomUUID if available, fallback to timestamp + random
	const uniqueId = typeof crypto !== 'undefined' && crypto.randomUUID
		? crypto.randomUUID()
		: `${now}_${Math.random().toString(36).substring(2, 9)}`;

	const boost: ActiveBoost = {
		id: `${abilityId}_${uniqueId}`,
		type: abilityDef.type,
		name: abilityDef.name,
		activatedAt: now,
		duration: abilityDef.duration,
		incomeMultiplier: abilityDef.incomeMultiplier,
		fanMultiplier: abilityDef.fanMultiplier
	};

	// Add to active boosts
	state.activeBoosts.push(boost);

	// Track usage for cost scaling
	if (!state.abilityUsageCount) {
		state.abilityUsageCount = {};
	}
	state.abilityUsageCount[abilityDef.type] = (state.abilityUsageCount[abilityDef.type] || 0) + 1;

	return true;
}

/**
 * Process active boosts - remove expired ones
 * Should be called each game tick to clean up expired boosts
 *
 * @param state - The current game state (will be mutated)
 * @param deltaTime - Time elapsed since last update in milliseconds (not used but kept for consistency)
 */
export function processActiveBoosts(state: GameState, deltaTime: number): void {
	const currentTime = Date.now();

	// Remove expired boosts
	state.activeBoosts = state.activeBoosts.filter((boost) => {
		const elapsedTime = currentTime - boost.activatedAt;
		return elapsedTime < boost.duration;
	});
}

/**
 * Get all abilities that are currently available to the player
 * Filters based on phase progression and unlocked systems
 *
 * @param state - The current game state
 * @returns Array of available ability definitions
 */
export function getAvailableAbilities(state: GameState): BoostDefinition[] {
	const available: BoostDefinition[] = [];

	// Phase 1: Streaming Exploitation (always available)
	if (state.phase >= 1) {
		available.push(
			...BOOSTS.filter((boost) =>
				['bot_streams', 'playlist_placement', 'social_media_campaign'].includes(boost.type)
			)
		);
	}

	// Phase 2: Physical Album Exploitation
	if (state.phase >= 2 && state.unlockedSystems.physicalAlbums) {
		available.push(
			...BOOSTS.filter((boost) =>
				[
					'limited_edition_variants',
					'shut_down_competitors',
					'exclusive_retailer_deals'
				].includes(boost.type)
			)
		);
	}

	// Phase 3: Concert/Tour Exploitation
	if (state.phase >= 3 && state.unlockedSystems.tours) {
		available.push(
			...BOOSTS.filter((boost) =>
				['scalp_records', 'limit_tickets', 'scalp_tickets', 'fomo_marketing'].includes(
					boost.type
				)
			)
		);
	}

	// Phase 4+: Platform Ownership Exploitation
	if (state.phase >= 4 && state.unlockedSystems.platformOwnership) {
		available.push(...BOOSTS.filter((boost) => boost.type === 'dynamic_pricing'));
	}

	return available;
}

/**
 * Calculate the current cost to activate an ability
 * Cost scales up with each use based on the ability's costScaling multiplier
 *
 * @param state - The current game state
 * @param abilityId - The unique ID of the ability
 * @returns The current cost in dollars, or 0 if ability not found
 */
export function calculateAbilityCost(state: GameState, abilityId: string): number {
	const abilityDef = getAbilityById(abilityId);
	if (!abilityDef) {
		return 0;
	}

	// Get usage count for this ability type
	const usageCount = state.abilityUsageCount?.[abilityDef.type] || 0;

	// Calculate scaled cost: baseCost * (costScaling ^ usageCount)
	const cost = abilityDef.baseCost * Math.pow(abilityDef.costScaling, usageCount);

	return cost;
}

/**
 * Get an ability definition by its ID
 *
 * @param abilityId - The unique ability identifier
 * @returns The ability definition or undefined if not found
 */
export function getAbilityById(abilityId: string): BoostDefinition | undefined {
	return BOOSTS.find((boost) => boost.id === abilityId);
}

/**
 * Get all active boosts that are currently affecting the game
 * Excludes expired boosts
 *
 * @param state - The current game state
 * @returns Array of currently active boosts
 */
export function getActiveBoosts(state: GameState): ActiveBoost[] {
	const currentTime = Date.now();

	return state.activeBoosts.filter((boost) => {
		const elapsedTime = currentTime - boost.activatedAt;
		return elapsedTime < boost.duration;
	});
}

/**
 * Get the remaining time for an active boost in milliseconds
 *
 * @param boost - The active boost
 * @returns Remaining time in milliseconds, or 0 if expired
 */
export function getRemainingTime(boost: ActiveBoost): number {
	const currentTime = Date.now();
	const elapsedTime = currentTime - boost.activatedAt;
	const remaining = boost.duration - elapsedTime;

	return Math.max(0, remaining);
}

/**
 * Check if a specific boost type is currently active
 *
 * @param state - The current game state
 * @param boostType - The boost type to check
 * @returns True if at least one boost of this type is active
 */
export function isBoostActive(state: GameState, boostType: BoostType): boolean {
	const currentTime = Date.now();

	return state.activeBoosts.some((boost) => {
		if (boost.type !== boostType) return false;

		const elapsedTime = currentTime - boost.activatedAt;
		return elapsedTime < boost.duration;
	});
}
