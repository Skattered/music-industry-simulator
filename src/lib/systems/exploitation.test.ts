import { describe, it, expect, beforeEach, vi } from 'vitest';
import {
	activateAbility,
	processActiveBoosts,
	getAvailableAbilities,
	calculateAbilityCost,
	getAbilityById,
	getActiveBoosts,
	getRemainingTime,
	isBoostActive
} from './exploitation';
import type { GameState } from '../game/types';

// Helper function to create a minimal game state for testing
function createTestState(overrides: Partial<GameState> = {}): GameState {
	return {
		money: 1_000_000_000, // Start with plenty of money for tests
		songs: [],
		fans: 0,
		gpu: 0,
		phase: 1,
		industryControl: 0,
		currentArtist: {
			name: 'Test Artist',
			songs: 0,
			fans: 0,
			peakFans: 0,
			createdAt: Date.now()
		},
		legacyArtists: [],
		songQueue: [],
		songGenerationSpeed: 30000,
		currentTrendingGenre: null,
		trendDiscoveredAt: null,
		techTier: 1,
		techSubTier: 0,
		upgrades: {},
		activeBoosts: [],
		abilityUsageCount: {},
		physicalAlbums: [],
		tours: [],
		ownedPlatforms: [],
		prestigeCount: 0,
		experienceMultiplier: 1.0,
		unlockedSystems: {
			trendResearch: false,
			physicalAlbums: false,
			tours: false,
			platformOwnership: false,
			monopoly: false,
			prestige: false,
			gpu: false
		},
		lastUpdate: Date.now(),
		createdAt: Date.now(),
		version: '1.0.0',
		...overrides
	};
}

describe('Exploitation System', () => {
	describe('getAbilityById', () => {
		it('should return ability definition by ID', () => {
			const ability = getAbilityById('bot_streams');
			expect(ability).toBeDefined();
			expect(ability?.id).toBe('bot_streams');
			expect(ability?.type).toBe('bot_streams');
		});

		it('should return undefined for non-existent ability', () => {
			const ability = getAbilityById('nonexistent');
			expect(ability).toBeUndefined();
		});
	});

	describe('getAvailableAbilities', () => {
		it('should return Phase 1 abilities for new game', () => {
			const state = createTestState({ phase: 1 });
			const available = getAvailableAbilities(state);

			expect(available.length).toBe(3);
			expect(available.map((a) => a.type)).toContain('bot_streams');
			expect(available.map((a) => a.type)).toContain('playlist_placement');
			expect(available.map((a) => a.type)).toContain('social_media_campaign');
		});

		it('should include Phase 2 abilities when physical albums unlocked', () => {
			const state = createTestState({
				phase: 2,
				unlockedSystems: {
					trendResearch: false,
					physicalAlbums: true,
					tours: false,
					platformOwnership: false,
					monopoly: false,
					prestige: false,
					gpu: false
				}
			});
			const available = getAvailableAbilities(state);

			expect(available.length).toBeGreaterThan(3);
			expect(available.map((a) => a.type)).toContain('limited_edition_variants');
			expect(available.map((a) => a.type)).toContain('shut_down_competitors');
			expect(available.map((a) => a.type)).toContain('exclusive_retailer_deals');
		});

		it('should include Phase 3 abilities when tours unlocked', () => {
			const state = createTestState({
				phase: 3,
				unlockedSystems: {
					trendResearch: false,
					physicalAlbums: true,
					tours: true,
					platformOwnership: false,
					monopoly: false,
					prestige: false,
					gpu: false
				}
			});
			const available = getAvailableAbilities(state);

			expect(available.map((a) => a.type)).toContain('scalp_tickets');
			expect(available.map((a) => a.type)).toContain('limit_tickets');
			expect(available.map((a) => a.type)).toContain('fomo_marketing');
		});

		it('should include Phase 4+ abilities when platform ownership unlocked', () => {
			const state = createTestState({
				phase: 4,
				unlockedSystems: {
					trendResearch: false,
					physicalAlbums: true,
					tours: true,
					platformOwnership: true,
					monopoly: false,
					prestige: false,
					gpu: false
				}
			});
			const available = getAvailableAbilities(state);

			expect(available.map((a) => a.type)).toContain('dynamic_pricing');
		});
	});

	describe('calculateAbilityCost', () => {
		it('should return base cost for first use', () => {
			const state = createTestState();
			const cost = calculateAbilityCost(state, 'bot_streams');

			// Base cost for bot_streams is 100,000
			expect(cost).toBe(100_000);
		});

		it('should scale cost after first use', () => {
			const state = createTestState({
				abilityUsageCount: {
					bot_streams: 1
				}
			});
			const cost = calculateAbilityCost(state, 'bot_streams');

			// Cost should be baseCost * (1.5 ^ 1) = 100,000 * 1.5 = 150,000
			expect(cost).toBe(150_000);
		});

		it('should scale cost exponentially with multiple uses', () => {
			const state = createTestState({
				abilityUsageCount: {
					bot_streams: 3
				}
			});
			const cost = calculateAbilityCost(state, 'bot_streams');

			// Cost should be baseCost * (1.5 ^ 3) = 100,000 * 3.375 = 337,500
			expect(cost).toBe(337_500);
		});

		it('should return 0 for non-existent ability', () => {
			const state = createTestState();
			const cost = calculateAbilityCost(state, 'nonexistent');

			expect(cost).toBe(0);
		});

		it('should track usage independently for different abilities', () => {
			const state = createTestState({
				abilityUsageCount: {
					bot_streams: 2,
					playlist_placement: 1
				}
			});

			const botCost = calculateAbilityCost(state, 'bot_streams');
			const playlistCost = calculateAbilityCost(state, 'playlist_placement');

			// bot_streams: 100,000 * (1.5 ^ 2) = 225,000
			expect(botCost).toBe(225_000);
			// playlist_placement: 500,000 * (1.5 ^ 1) = 750,000
			expect(playlistCost).toBe(750_000);
		});
	});

	describe('activateAbility', () => {
		it('should activate ability and deduct cost', () => {
			const state = createTestState({ money: 200_000 });
			const success = activateAbility(state, 'bot_streams');

			expect(success).toBe(true);
			expect(state.money).toBe(100_000); // 200,000 - 100,000
			expect(state.activeBoosts.length).toBe(1);
			expect(state.activeBoosts[0].type).toBe('bot_streams');
		});

		it('should fail if player cannot afford ability', () => {
			const state = createTestState({ money: 50_000 });
			const success = activateAbility(state, 'bot_streams');

			expect(success).toBe(false);
			expect(state.money).toBe(50_000); // Unchanged
			expect(state.activeBoosts.length).toBe(0);
		});

		it('should fail if ability does not exist', () => {
			const state = createTestState({ money: 1_000_000 });
			const success = activateAbility(state, 'nonexistent');

			expect(success).toBe(false);
			expect(state.money).toBe(1_000_000); // Unchanged
		});

		it('should fail if ability is not available for current phase', () => {
			const state = createTestState({ money: 100_000_000, phase: 1 });
			const success = activateAbility(state, 'dynamic_pricing');

			expect(success).toBe(false);
			expect(state.activeBoosts.length).toBe(0);
		});

		it('should apply correct multipliers from ability definition', () => {
			const state = createTestState({ money: 200_000 });
			activateAbility(state, 'bot_streams');

			const boost = state.activeBoosts[0];
			expect(boost.incomeMultiplier).toBe(3.0);
			expect(boost.fanMultiplier).toBe(1.5);
		});

		it('should track usage count', () => {
			const state = createTestState({ money: 500_000 });

			activateAbility(state, 'bot_streams');
			expect(state.abilityUsageCount?.bot_streams).toBe(1);

			activateAbility(state, 'bot_streams');
			expect(state.abilityUsageCount?.bot_streams).toBe(2);
		});

		it('should allow multiple different abilities to be active simultaneously', () => {
			const state = createTestState({ money: 10_000_000 });

			activateAbility(state, 'bot_streams');
			activateAbility(state, 'playlist_placement');
			activateAbility(state, 'social_media');

			expect(state.activeBoosts.length).toBe(3);
			expect(state.activeBoosts.map((b) => b.type)).toContain('bot_streams');
			expect(state.activeBoosts.map((b) => b.type)).toContain('playlist_placement');
			expect(state.activeBoosts.map((b) => b.type)).toContain('social_media_campaign');
		});

		it('should allow same ability to be activated multiple times', () => {
			const state = createTestState({ money: 10_000_000 });

			activateAbility(state, 'bot_streams');
			activateAbility(state, 'bot_streams');

			expect(state.activeBoosts.length).toBe(2);
			expect(state.activeBoosts[0].type).toBe('bot_streams');
			expect(state.activeBoosts[1].type).toBe('bot_streams');
		});

		it('should create unique IDs for each activation', () => {
			const state = createTestState({ money: 10_000_000 });

			activateAbility(state, 'bot_streams');
			activateAbility(state, 'bot_streams');

			expect(state.activeBoosts[0].id).not.toBe(state.activeBoosts[1].id);
		});

		it('should set activation timestamp', () => {
			const before = Date.now();
			const state = createTestState({ money: 200_000 });
			activateAbility(state, 'bot_streams');
			const after = Date.now();

			const boost = state.activeBoosts[0];
			expect(boost.activatedAt).toBeGreaterThanOrEqual(before);
			expect(boost.activatedAt).toBeLessThanOrEqual(after);
		});
	});

	describe('processActiveBoosts', () => {
		it('should remove expired boosts', () => {
			const now = Date.now();
			const state = createTestState({
				activeBoosts: [
					{
						id: 'test1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 60000, // 60 seconds ago
						duration: 30000, // 30 second duration - EXPIRED
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test2',
						type: 'playlist_placement',
						name: 'Playlist Payola',
						activatedAt: now - 10000, // 10 seconds ago
						duration: 60000, // 60 second duration - STILL ACTIVE
						incomeMultiplier: 2.5,
						fanMultiplier: 3.0
					}
				]
			});

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(1);
			expect(state.activeBoosts[0].type).toBe('playlist_placement');
		});

		it('should keep all active boosts', () => {
			const now = Date.now();
			const state = createTestState({
				activeBoosts: [
					{
						id: 'test1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test2',
						type: 'playlist_placement',
						name: 'Playlist Payola',
						activatedAt: now - 5000,
						duration: 60000,
						incomeMultiplier: 2.5,
						fanMultiplier: 3.0
					}
				]
			});

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(2);
		});

		it('should handle empty boost array', () => {
			const state = createTestState({ activeBoosts: [] });

			processActiveBoosts(state, 100);

			expect(state.activeBoosts.length).toBe(0);
		});
	});

	describe('getActiveBoosts', () => {
		it('should return only non-expired boosts', () => {
			const now = Date.now();
			const state = createTestState({
				activeBoosts: [
					{
						id: 'test1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 60000, // Expired
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					},
					{
						id: 'test2',
						type: 'playlist_placement',
						name: 'Playlist Payola',
						activatedAt: now - 10000, // Active
						duration: 60000,
						incomeMultiplier: 2.5,
						fanMultiplier: 3.0
					}
				]
			});

			const active = getActiveBoosts(state);

			expect(active.length).toBe(1);
			expect(active[0].type).toBe('playlist_placement');
		});
	});

	describe('getRemainingTime', () => {
		it('should calculate remaining time correctly', () => {
			const now = Date.now();
			const boost = {
				id: 'test1',
				type: 'bot_streams' as const,
				name: 'Bot Streams',
				activatedAt: now - 10000, // 10 seconds ago
				duration: 30000, // 30 second duration
				incomeMultiplier: 3.0,
				fanMultiplier: 1.5
			};

			const remaining = getRemainingTime(boost);

			expect(remaining).toBeCloseTo(20000, -2); // ~20 seconds remaining
		});

		it('should return 0 for expired boost', () => {
			const now = Date.now();
			const boost = {
				id: 'test1',
				type: 'bot_streams' as const,
				name: 'Bot Streams',
				activatedAt: now - 60000,
				duration: 30000,
				incomeMultiplier: 3.0,
				fanMultiplier: 1.5
			};

			const remaining = getRemainingTime(boost);

			expect(remaining).toBe(0);
		});
	});

	describe('isBoostActive', () => {
		it('should return true when boost type is active', () => {
			const now = Date.now();
			const state = createTestState({
				activeBoosts: [
					{
						id: 'test1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 10000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			expect(isBoostActive(state, 'bot_streams')).toBe(true);
		});

		it('should return false when boost type is not active', () => {
			const state = createTestState({ activeBoosts: [] });

			expect(isBoostActive(state, 'bot_streams')).toBe(false);
		});

		it('should return false when boost is expired', () => {
			const now = Date.now();
			const state = createTestState({
				activeBoosts: [
					{
						id: 'test1',
						type: 'bot_streams',
						name: 'Bot Streams',
						activatedAt: now - 60000,
						duration: 30000,
						incomeMultiplier: 3.0,
						fanMultiplier: 1.5
					}
				]
			});

			expect(isBoostActive(state, 'bot_streams')).toBe(false);
		});
	});

	describe('Integration: Full ability lifecycle', () => {
		it('should handle complete activation, usage, and expiration cycle', () => {
			const state = createTestState({ money: 1_000_000 });

			// First activation at base cost
			const cost1 = calculateAbilityCost(state, 'bot_streams');
			expect(cost1).toBe(100_000);

			const success1 = activateAbility(state, 'bot_streams');
			expect(success1).toBe(true);
			expect(state.money).toBe(900_000);
			expect(state.activeBoosts.length).toBe(1);

			// Second activation at scaled cost
			const cost2 = calculateAbilityCost(state, 'bot_streams');
			expect(cost2).toBe(150_000); // 1.5x scaling

			const success2 = activateAbility(state, 'bot_streams');
			expect(success2).toBe(true);
			expect(state.money).toBe(750_000);
			expect(state.activeBoosts.length).toBe(2);

			// Process boosts (still active)
			processActiveBoosts(state, 100);
			expect(state.activeBoosts.length).toBe(2);

			// Manually expire the boosts by setting their activation time in the past
			state.activeBoosts[0].activatedAt = Date.now() - 60000;
			state.activeBoosts[1].activatedAt = Date.now() - 60000;

			// Process again (now expired)
			processActiveBoosts(state, 100);
			expect(state.activeBoosts.length).toBe(0);

			// Usage count persists after expiration
			expect(state.abilityUsageCount?.bot_streams).toBe(2);

			// Third activation should use even higher cost
			const cost3 = calculateAbilityCost(state, 'bot_streams');
			expect(cost3).toBe(225_000); // 1.5^2 scaling
		});
	});
});
